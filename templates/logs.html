<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Error Logs</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
<nav><a href="{{ url_for('home') }}">Home</a> · <a href="{{ url_for('dashboard.index') }}">Dashboard</a></nav>
<h1>Error Logs <span id="live-dot" style="color:#16a34a;">● LIVE</span></h1>

<div class="controls" style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;">
    <label for="level">Level</label>
    <select id="level">
        <option value="">All</option>
        <option>ERROR</option>
        <option>WARNING</option>
        <option>INFO</option>
        <option>DEBUG</option>
    </select>
    <label for="ip">IP</label>
    <input id="ip" placeholder="IP (optional)"/>
    <span id="status" style="font-size:0.9rem;color:#6b7280;">Auto-updating…</span>
</div>

<table class="table">
    <thead>
    <tr>
        <th>Time</th>
        <th>Level</th>
        <th>Component</th>
        <th>IP</th>
        <th>Message</th>
    </tr>
    </thead>
    <tbody id="tbody"></tbody>
</table>

<h2 style="margin-top:24px;">Live Miner Logs</h2>
<p style="color:#6b7280;font-size:0.9rem;">Enter a miner IP above and click "Load Live Miner Logs" to fetch logs directly from the device.</p>
<div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:8px;">
    <button id="load-live">Load Live Miner Logs</button>
</div>
<table class="table">
    <thead>
    <tr>
        <th>Time</th>
        <th>Level</th>
        <th>Message</th>
    </tr>
    </thead>
    <tbody id="live-body"></tbody>
</table>

<script>
    const tbody = document.getElementById('tbody');
    const levelEl = document.getElementById('level');
    const ipEl = document.getElementById('ip');
    const statusEl = document.getElementById('status');

    let pollTimer = null;
    let lastTs = null; // ISO string of the newest seen created_at
    const seenIds = new Set();

    function showEmptyRow() {
        if (!document.getElementById('empty-row')) {
            const tr = document.createElement('tr');
            tr.id = 'empty-row';
            const td = document.createElement('td');
            td.colSpan = 5;
            td.style.textAlign = 'center';
            td.style.color = '#888';
            td.textContent = 'No logs to display at this time.';
            tr.appendChild(td);
            tbody.appendChild(tr);
        }
    }

    function removeEmptyRow() {
        const el = document.getElementById('empty-row');
        if (el) el.remove();
    }

    function buildUrl(incremental = false) {
        let url = '/api/error-logs?limit=200';
        const lvl = levelEl.value;
        const ip = ipEl.value.trim();
        if (lvl) url += `&level=${encodeURIComponent(lvl)}`;
        if (ip) url += `&ip=${encodeURIComponent(ip)}`;
        if (incremental && lastTs) url += `&since=${encodeURIComponent(lastTs)}`;
        return url;
    }

    function renderRows(rows, {prepend = false} = {}) {
        // rows are from API in desc order (newest first)
        // We want to maintain newest at top. When prepending, process oldest->newest and insertBefore firstChild.
        const toProcess = prepend ? [...rows].reverse() : rows;
        if (toProcess.length) removeEmptyRow();
        toProcess.forEach(r => {
            if (seenIds.has(r.id)) return;
            seenIds.add(r.id);
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${r.created_at}</td><td>${r.level}</td><td>${r.component}</td><td>${r.miner_ip || ''}</td><td>${r.message}</td>`;
            if (prepend) {
                tbody.insertBefore(tr, tbody.firstChild);
            } else {
                tbody.appendChild(tr);
            }
            // track latest timestamp
            if (!lastTs || r.created_at > lastTs) lastTs = r.created_at;
        });
    }

    async function initialLoad() {
        statusEl.textContent = 'Loading…';
        try {
            const res = await fetch(buildUrl(false));
            const data = await res.json();
            tbody.innerHTML = '';
            seenIds.clear();
            lastTs = null;
            // Show newest first as returned
            renderRows(data, {prepend: false});
            // compute lastTs
            data.forEach(r => {
                if (!lastTs || r.created_at > lastTs) lastTs = r.created_at;
            });
            if (Array.isArray(data) && data.length === 0) {
                showEmptyRow();
            }
            statusEl.textContent = 'Auto-updating…';
        } catch (e) {
            statusEl.textContent = 'Failed to load';
        }
    }

    async function pollOnce() {
        try {
            const res = await fetch(buildUrl(true));
            const data = await res.json();
            if (Array.isArray(data) && data.length) {
                renderRows(data, {prepend: true});
            }
        } catch (e) {
            // transient errors ignored
        }
    }

    function startPolling() {
        if (pollTimer) clearInterval(pollTimer);
        pollTimer = setInterval(pollOnce, 3000);
    }

    function resetAndReload() {
        tbody.innerHTML = '';
        seenIds.clear();
        lastTs = null;
        initialLoad();
    }

    // react to filter changes
    levelEl.addEventListener('change', resetAndReload);
    let ipDebounce;
    ipEl.addEventListener('input', () => {
        clearTimeout(ipDebounce);
        ipDebounce = setTimeout(resetAndReload, 400);
    });

    // --- Live Miner Logs (direct from device) ---
    const liveBtn = document.getElementById('load-live');
    const liveBody = document.getElementById('live-body');

    async function loadLive() {
        const ip = ipEl.value.trim();
        liveBody.innerHTML = '';
        if (!ip) {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td colspan="3">Enter an IP above to fetch live miner logs.</td>`;
            liveBody.appendChild(tr);
            return;
        }
        try {
            const res = await fetch(`/api/miner/${encodeURIComponent(ip)}/logs`);
            const payload = await res.json();
            if (!payload.ok) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="3">Error: ${payload.error || 'Failed to fetch logs'}</td>`;
                liveBody.appendChild(tr);
                return;
            }
            const entries = Array.isArray(payload.entries) ? payload.entries : [];
            if (!entries.length) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="3">No live log entries returned.</td>`;
                liveBody.appendChild(tr);
                return;
            }
            entries.forEach(e => {
                const level = String(e.level || 'INFO').toUpperCase();
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${e.ts || '—'}</td><td>${level}</td><td>${e.message || ''}</td>`;
                liveBody.appendChild(tr);
            });
        } catch (e) {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td colspan="3">Request failed.</td>`;
            liveBody.appendChild(tr);
        }
    }

    liveBtn.addEventListener('click', loadLive);

    window.addEventListener('DOMContentLoaded', async () => {
        await initialLoad();
        startPolling();
    });

    window.addEventListener('beforeunload', () => {
        if (pollTimer) clearInterval(pollTimer);
    });
</script>
</body>
</html>
